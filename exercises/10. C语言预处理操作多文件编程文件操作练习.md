# C语言预处理操作多文件编程文件操作练习

## 1. 以下程序运行后的输出结果是（）

```C
#define S(x) 4*x*x+1
int main()
{
    int i = 6, j = 8;
    printf("%d\n", S(i + j));
}
```

- [ ] A. 21
- [ ] B. 41
- [ ] C. 61
- [ ] D. 81

<details>
<summary><font color=red>查看解析</font></summary>

选择**D. 81**

这个问题涉及到C语言中宏定义的使用。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`S(x)`被替换为`4*x*x+1`，然后在`main`函数中，使用`S(i + j)`，这会被替换为`4*i + j*i + j+1`，而不是我们可能期望的`4*(i + j)*(i + j)+1`。

所以，`S(i + j)`的值是$4 \times 6 + 8 \times 6 + 8 + 1 = 24 + 48 + 8 + 1 = 81$。

</details>

## 2. 设有如下程序段，则数组 `a` 的元素个数和最后一个元素分别为 （）

```C
#define N 3
#define M N+2
float a[M][N];
```

- [ ] A. 15,a[5][3]
- [ ] B. 15,a[3][5]
- [ ] C. 8,a[4][2]
- [ ] D. 15,a[4][2]

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D. 15,a[4][2]**

这个问题涉及到C语言中宏定义的使用和数组的定义。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`N`被替换为3，`M`被替换为`N+2`，然后在定义数组`a`时，使用`a[M][N]`，这会被替换为`a[N+2][N]`，而不是我们可能期望的`a[5][3]`。

所以，数组`a`的元素个数是$(N + 2) \times N = 5 \times 3 = 15$，最后一个元素是`a[4][2]`。

</details>

## 3. 以下有关宏替换的叙述错误的是()

- [ ] A. 宏名必须用大与字母表示
- [ ] B. 宏替换不占用运行时间
- [ ] C. 宏名不具有类型
- [ ] D. 宏替换只是字符替换

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A. 宏名必须用大与字母表示**

这个问题涉及到C语言中宏替换的特性。

在C语言中，宏替换是在预处理阶段进行的文本替换，不占用运行时间。

宏名不具有类型，因为它只是一个文本替换的标识符。

宏替换只是字符替换，没有进行任何运算符优先级的处理。

但是，宏名并不必须用大写字母表示，这只是一种编程习惯，以便于区分宏和其他变量。所以，选项A的叙述是错误的。

</details>

## 4. 请读下面的程序，程序的输出结果是()

```C
#define SUB(X, Y) (X) * Y
int main()
{
	int a = 3, b = 4;
	printf("%d", SUB(a++, b++));
}
```

- [ ] A. 12
- [ ] B. 15
- [ ] C. 16
- [ ] D. 20

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A. 12**

这个问题涉及到C语言中宏定义的使用和运算符优先级。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`SUB(X, Y)`被替换为`(X) * Y`，然后在`main`函数中，使用`SUB(a++, b++)`，这会被替换为`(a++) * b++`。

由于`*`运算符的优先级高于`++`运算符，所以`a++`会先与`b`相乘，然后`a`和`b`都会自增。所以，`SUB(a++, b++)`的值是$3 \times 4 = 12$，然后`a`和`b`都会自增。

</details>

## 5. 以下程序的输出结果是（）。

```C
#define f(x) x*x
int main()
{
	int a = 6, b = 2, c;
	c = f(a) / f(b);
	printf("%d\n", c);
}
```

- [ ] A. 9
- [ ] B. 6
- [ ] C. 36
- [ ] D. 18

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 36**

这个问题涉及到C语言中宏定义的使用和运算符优先级。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`f(x)`被替换为`x*x`，然后在`main`函数中，使用`f(a) / f(b)`，这会被替换为`a*a / b*b`。

由于`/`运算符的优先级高于`*`运算符，所以`a*a / b`会先计算，然后再与`b`相乘。所以，`f(a) / f(b)`的值是$6 \times 6 \div 2 \times 2 = 36 \div 2 \times 2 = 18 \times 2 = 36$。

</details>

## 6. 下列程序执行后的输出结果是（）。

```C
#define MA(x) x*(x-1)
int main() {
	int a = 1, b = 2;
	printf("%d \n", MA(1 + a + b));
}
```

- [ ] A. 6
- [ ] B. 8
- [ ] C. 10
- [ ] D. 12

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. 8**

这个问题涉及到C语言中宏定义的使用和运算符优先级。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`MA(x)`被替换为`x*(x-1)`，然后在`main`函数中，使用`MA(1 + a + b)`，这会被替换为`1 + a + b*(1 + a + b - 1)`。

由于`*`运算符的优先级高于`+`运算符，所以`b*(1 + a + b - 1)`会先计算，然后再与`1 + a`相加。所以，`MA(1 + a + b)`的值是$1 + 1 + 2 \times (1 + 1 + 2 - 1) = 1 + 1 + 2 \times 3 = 1 + 1 + 6 = 8$。

</details>

## 7. 有如下程序，该程序中`for`循环执行的次数是（）

```C
#define N 2
#define M N+1
#define NUM 2*M+1
int main() {
	int i;
	for (i = 1; i <= NUM; i++)printf("%d\n", i);
}
```

- [ ] A. 5
- [ ] B. 6
- [ ] C. 7
- [ ] D. 8

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. 6**

这个问题涉及到C语言中宏定义的使用。

在C语言中，宏定义是在预处理阶段进行的文本替换。

在这个问题中，宏定义`N`被替换为`2`，`M`被替换为`N+1`，`NUM`被替换为`2*M+1`。然后在`main`函数中，`for`循环的条件是`i <= NUM`。

由于宏替换只是文本替换，没有进行任何运算符优先级的处理，所以`NUM`被替换为`2*M+1`，然后`M`被替换为`N+1`，所以`NUM`的值是`2*N+1+1`，即$2 \times 2 + 1 + 1 = 6$。

所以，`for`循环执行的次数是6。

</details>

## 8. 以下程序运行后的输出结果是（）

```C
# define f(x) (x*x)
int main() {
	int i1, i2;
	i1 = f(8) / f(4);
	i2 = f(4 + 4) / f(2 + 2);
	printf("%d, %d\n", i1, i2);
}
```

- [ ] A. 64,28
- [ ] B. 4,4
- [ ] C. 4,3
- [ ] D. 64,64

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 4,3**

这个问题涉及到C语言中宏定义的使用。

在C语言中，宏定义是在预处理阶段进行的文本替换。

在这个问题中，宏定义`f(x)`被替换为`(x*x)`，然后在`main`函数中，使用`f(8) / f(4)`和`f(4 + 4) / f(2 + 2)`。

对于`f(8) / f(4)`，`f(8) / f(4)`会被替换为`(8*8) / (4*4)`，即`64 / 16`，结果为`4`。

对于`f(4 + 4) / f(2 + 2)`，`f(4 + 4) / f(2 + 2)`会被替换为`(4 + 4 * 4 + 4) / (2 + 2 * 2 + 2)`，即`24 / 8`，结果为`3`。

所以，这个程序的输出结果是4和3。

</details>

## 9. 执行以下代码， `a` 的值为 （）

```C
#define SUM(x,y) x+y
int a = 3;
int b = 2;
a += a * SUM(a, b) * b;
```

- [ ] A. 16
- [ ] B. 33
- [ ] C. 30
- [ ] D. 39

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A. 16**

这个问题涉及到C语言中宏定义的使用和运算符优先级。

在C语言中，宏定义是在预处理阶段进行的文本替换，没有进行任何运算符优先级的处理。

在这个问题中，宏定义`SUM(x,y)`被替换为`x+y`，然后在`a += a * SUM(a, b) * b;`这行代码中，`SUM(a, b)`会被替换为`a+b`，即`3+2`。

故整行代码相当于`a = 3 + 3 * 3 + 2 * 2`，结果为$3 + 9 + 4 = 16$

所以最后`a`的值为`16`。

</details>

## 10. 以下叙述中正确的是 （）

- [ ] A. 预处理命令行须位于源文件的开头
- [ ] B. 在源文件的一行上可以有多条预处理命令
- [ ] C. 宏名之须用大写字母表示
- [ ] D. 宏替换不占用程序的运行时间

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D. 宏替换不占用程序的运行时间**

这个问题涉及到C语言的预处理命令。

以下是对每个选项的分析：

- A. 预处理命令行须位于源文件的开头：这是错误的。预处理命令可以位于源文件的任何位置，只要在使用之前定义就可以。

- B. 在源文件的一行上可以有多条预处理命令：这是错误的。每一行只能有一条预处理命令。

- C. 宏名之须用大写字母表示：这是错误的。虽然习惯上宏名使用大写字母，但这并不是必须的。

- D. 宏替换不占用程序的运行时间：这是正确的。宏替换在编译阶段完成，不会占用程序的运行时间。

</details>

## 11. 宏定义经`DIV (x+5,y-5)`引用，替换展开后是 （）

```C
#define DIV(a, b) a / b
```

- [ ] A. `x+5/y-5`
- [ ] B. `(x+5/y-5)`
- [ ] C. `(x+5)/(y-5)`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A. `x+5/y-5`**

这个问题涉及到C语言中宏定义的使用。

在C语言中，宏定义是在预处理阶段进行的文本替换。

在这个问题中，宏定义`DIV(a, b)`被替换为`a / b`，然后在`DIV (x+5,y-5)`中，`DIV(a, b)`会被替换为`x+5/y-5`。

</details>

## 12. `a` 的定义与下面哪个语句等价 （）

```C
typedef int * T;
T a[10];
```

- [ ] A. `int (*a)[10];`
- [ ] B. `int* a[10];`
- [ ] C. `int *a;`
- [ ] D. `int a[10];`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. `int* a[10];`**

这个问题涉及到C语言中的类型定义（typedef）和指针数组。

在这个问题中，`typedef int * T;`定义了一个新的类型`T`，`T`是一个指向整型的指针。

然后`T a[10];`定义了一个`T`类型的数组，数组长度为10，也就是说，`a`是一个包含10个指向整型的指针的数组。

所以，`T a[10];`等价于`int* a[10];`。

</details>

## 13. 引用标准库时，下面的说法正确的是（）

- [ ] A. 语句 `#include "stdlib.h"`是正确的，而且程序编译速度比`#include <stdlib.h>`要快
- [ ] B. 语句 `#include <stdlib.h>`是正确的，而且程序编译速度比`#include "stdlib.h"`要快
- [ ] C. 语句 `#include <stdlib.h>`和`#include "stdlib.h"`都是确的，程序编译速度没有区别
- [ ] D. 语句 `#include "stdlib.h"`是错误的

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. 语句 `#include <stdlib.h>`是正确的，而且程序编译速度比`#include "stdlib.h"`要快**

这个问题涉及到C语言中的预处理指令`#include`。

`#include`指令用于包含头文件，它有两种形式：`#include <filename>`和`#include "filename"`。

- `#include <filename>`：这种形式用于包含系统头文件，它会在系统头文件目录中查找文件。

- `#include "filename"`：这种形式用于包含用户自定义的头文件，它首先在当前目录中查找文件，如果没有找到，再在系统头文件目录中查找。

所以，`#include <stdlib.h>`和`#include "stdlib.h"`都是正确的，它们的区别在于查找文件的位置不同，而在题目中的情况考虑，引用标准库肯定需要先从系统头文件开始查找速度要更快一些，故`#include <stdlib.h>`编译速度比`#include "stdlib.h"`要快。

</details>

## 14. 对于`#include <filename.h>`和`#include "filename.h"`，以下说法错误的是（）

- [ ] A. `#include <filename.h>`只搜索标准库路径
- [ ] B. `#include "filename.h"`只搜索用户工作路径
- [ ] C. `#include <filename.h>`搜索范围比`#include "filename.h"`小
- [ ] D. 两者有时可能等价

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. `#include "filename.h"`只搜索用户工作路径**

这个问题涉及到C语言中的预处理指令`#include`。

`#include`指令用于包含头文件，它有两种形式：`#include <filename>`和`#include "filename"`。

- `#include <filename>`：这种形式用于包含系统头文件，它会在系统头文件目录中查找文件。

- `#include "filename"`：这种形式用于包含用户自定义的头文件，它首先在当前目录中查找文件，如果没有找到，再在系统头文件目录中查找。

所以，以下说法错误的是B。

`#include "filename.h"`不仅会搜索用户工作路径，如果在用户工作路径中没有找到文件，还会在系统头文件目录中查找。

</details>

## 15. `#define NUM 10 + 2` `printf("%d", NUM * 2);`结果为（）

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**14**

这个问题涉及到C语言中宏定义的运算优先级问题。

在这个问题中，宏定义`#define NUM 10 + 2`，然后在`printf("%d", NUM * 2);`中，`NUM`会被替换为`10 + 2`，所以这个语句等价于`printf("%d", 10 + 2 * 2);`。

由于乘法的优先级高于加法，所以这个表达式的结果是$10 + 4 = 14$，而不是$(10 + 2) * 2 = 24$。

</details>

## 16. 请问 `c` 的值是（  ）

```C
#define NUL(a,b) a/b
int c = 1 - MUL(4+8, 2+2)
```

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**3**

这个问题涉及到C语言中宏定义的使用。

在这个问题中，宏定义`#define MUL(a,b) a/b`，然后在`int c = 1 - MUL(4+8, 2+2);`中，`MUL(a, b)`会被替换为`4 + 8 / 2 + 2`。

所以，`c`的值为`1 - 4 + 8 / 2 + 2 = 1 - 4 + 4 + 2 = 1 + 2 = 3`。

</details>

## 17. 下列关于 `#iclude` 命令的叙述中，错误的是（）

- [ ] A. `#include` 命令中，文件名可以用双引号或尖括号括起来
- [ ] B. 一个被包含文件中又可以包含另一个被包含文件
- [ ] C. 一个 `#include` 命令中可以指定多个被包含文件
- [ ] D. 一个 `#include` 命令中只旨定一个被包含文件

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 一个 `#include` 命令中可以指定多个被包含文件**

这个问题涉及到C语言中的预处理指令`#include`。`#include`指令用于包含头文件。

- 选项A：`#include`命令中，文件名可以用双引号或尖括号括起来，这是正确的。

- 选项B：一个被包含文件中又可以包含另一个被包含文件，这也是正确的。

- 选项D：一个`#include`命令中只旨定一个被包含文件，这也是正确的。

- 选项C：一个`#include`命令中可以指定多个被包含文件，这是错误的。在C语言中，每个`#include`命令只能包含一个头文件。

</details>


## 18. 设有以下宏定义，则执行语句：`z=2 * (N+Y(5+1))` 后， `z` 的值为（）

```C
#define N 3
#define Y(n) ((N+1)*n)
```

- [ ] A. 出错
- [ ] B. 42
- [ ] C. 48
- [ ] D. 54

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 48**

这个问题涉及到C语言中的宏定义和运算优先级。

在这个问题中，有两个宏定义`#define N 3`和`#define Y(n) ((N+1)*n)`，然后在`z=2 * (N+Y(5+1));`中，`N`和`Y(n)`会被替换。

首先，`Y(5+1)`会被替换为`((N+1)*6)`，然后`N`会被替换为`3`，所以这个语句等价于`z=2 * (3 + ((3 + 1) * 5 + 1));`。

所以，`z`的值为$2 \times (3 + (20 + 1)) = 2 \times 24 = 48$。

</details>

## 19. 以下选项中正确的是 ()

- [ ] A. C语言的源程序不必通过编译就可以直云行
- [ ] B. C语言中的每条可执行语句最终都将被转换成二进制的机器指令
- [ ] C. C源程序经编译形成的二进制代码可以直接运行
- [ ] D. C语言中的函数不可以单独进行编译

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B. C语言中的每条可执行语句最终都将被转换成二进制的机器指令**

这个问题涉及到C语言的编译和运行过程。

- 选项A：C语言的源程序不必通过编译就可以直接运行，这是错误的。C语言的源程序必须经过编译，转换为机器语言，才能被计算机执行。

- 选项B：C语言中的每条可执行语句最终都将被转换成二进制的机器指令，这是正确的。这就是编译过程的目的。

- 选项C：C源程序经编译形成的二进制代码可以直接运行，这是错误的。编译后的二进制代码通常需要链接（link）过程，将多个对象文件和库文件链接成一个可执行文件，才能直接运行。

- 选项D：C语言中的函数不可以单独进行编译，这是错误的。在C语言中，可以将函数写在单独的源文件中，然后单独编译这个源文件。

</details>

## 20. 在C程序中，可把整型数以二进制形式存放到文件中的函数是 （）

- [ ] A. `fprintf`函数
- [ ] B. `fread`函数
- [ ] C. `fwrite`函数
- [ ] D. `fputc`函数

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. `fwrite`函数**

这个问题涉及到C语言中的文件操作函数。

- 选项A：`fprintf`函数是用于将格式化的数据写入文件，但它不是以二进制形式存放整型数。

- 选项B：`fread`函数是用于从文件中读取数据，而不是写入数据。

- 选项C：`fwrite`函数是用于将数据（包括整型数）以二进制形式写入文件，所以这是正确的。

- 选项D：`fputc`函数是用于将字符写入文件，而不是整型数。

</details>

## 21. 下列关于C的宏定义的说法中，不正确的是（）

- [ ] A. 宏定义的常量更容剔理解，如果可以使用宏定义常量的话，要避免使用 `const `常量
- [ ] B. 宏的嵌套定义过多会影响程序的可读性，而且很容易出错
- [ ] C. 相对于函数调用，宏定义可以提高程序的运行效率
- [ ] D. 宏定义不检查参数正确性，这样会有安全隐患

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A. 宏定义的常量更容易理解，如果可以使用宏定义常量的话，要避免使用 `const`常量**

这个问题涉及到C语言中宏定义。

- 选项A：这个说法是不正确的。虽然宏定义的常量在预处理阶段就已经被替换，但是`const`定义的常量在编译阶段会进行类型检查，而且`const`定义的常量在内存中只保留了一个副本，所以在大多数情况下，`const`常量更值得推荐。

- 选项B：宏的嵌套定义过多会影响程序的可读性，而且很容易出错。这个说法是正确的，因为宏定义过多会使得代码难以理解和维护。

- 选项C：相对于函数调用，宏定义可以提高程序的运行效率。这个说法是正确的，因为宏定义在预处理阶段就已经被替换，而函数调用需要在运行时进行。

- 选项D：宏定义不检查参数正确性，这样会有安全隐患。这个说法是正确的，因为宏定义只是简单的文本替换，不会进行类型检查或参数检查。

</details>

## 22. 以下程序运行的结果是 ()

```C
#define X 5
#define Y X+1
#define Z Y*X/2
int main()
{
	int a = Y;
	printf("%d,%d", Z, --a);
}
```

- [ ] A. 7,6
- [ ] B. 12,6
- [ ] C. 12,5
- [ ] D. 7,5

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D. 7,5**

这个问题涉及到C语言中的宏定义和运算优先级以及int类型除法。

在`main`函数中，有一个语句`int a = Y;`，这里的`Y`会被预处理器替换为`X+1`，然后`X`再被替换为`5`，所以`a`的值为`5+1=6`。

接下来是`printf`语句，`Z`会被替换为`Y*X/2`，然后`Y`和`X`分别被替换为`X+1`和`5`，所以`Z`的值为$5 + 1 \times 5 \div 2 = 5 + 2 = 7$。

`--a`的值为`6-1=5`。

所以，程序的输出结果是`7,5`。

</details>

## 23. 下面程序输出的是（）

```C
#define f(x) x*x
int main()
{
	int a = 5, b = 2, c;
	c = f(a) / f(b);
	printf("%d", c);
}
```

- [ ] A. 6.25
- [ ] B. 6
- [ ] C. 24
- [ ] D. 25

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 24**

这个题目主要考察了C语言中的宏定义和运算符优先级。

特别的，宏定义只是简单的文本替换，不会自动添加括号，因此在使用宏时，我们需要注意运算符的优先级和运算顺序。

在`main`函数中，有一个语句`c = f(a) / f(b);`，这里的`f(a)`和`f(b)`会被预处理器替换为`a*a`和`b*b`，然后`a`和`b`分别被替换为`5`和`2`。由于宏定义只是简单的文本替换，所以实际的表达式为`5*5/2*2`。

根据C语言的运算符优先级和运算顺序，`*`和`/`的优先级相同，从左到右计算，所以实际的计算顺序是$(5 \times 5 \div 2 ) \times 2 = 12 \times 2 = 24$。

所以，程序的输出结果是`24`。

</details>

## 25. 下列说法正确的是（）

- [ ] A. 函数`fscanf`不能从标准输入流读取数据
- [ ] B. 程序员须明确地用函数`fopen`打开标准输入流、标准输出流和标准错误流
- [ ] C. 程序须明确地调用函数`fclose`关闭文件
- [ ] D. 函数`fprintf`能够把数据写入标准输出流

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D. 函数`fprintf`能够把数据写入标准输出流**

这个题目主要考察了C语言中的文件操作和标准输入/输出流的使用。

选项A：函数`fscanf`可以从标准输入流读取数据`fscanf(*str, n, stdin);`，但是它也可以从任何打开的文件读取数据，所以这个说法是错误的。

选项B：标准输入流、标准输出流和标准错误流在程序开始执行时，就已经被自动打开，程序员无需明确地用函数`fopen`打开它们，所以这个说法是错误的。

选项C：程序在结束时，会自动关闭所有打开的文件，包括由`fopen`函数打开的文件。最好不要留给操作系统进行这个步骤，以免造成不可预知问题。所以，为了保证数据的完整性和减少资源占用，我们通常会在不再需要文件时，明确地调用函数`fclose`关闭文件，所以这个说法是错误的。

选项D：函数`fprintf`可以把数据写入任何打开的文件，包括标准输出流，所以这个说法是正确的。

</details>

## 25. 打开文件时选用的文件操作方式为" wb +"，则下列说法正确的是（）

- [ ] A. 要打开的文件是二进制文件
- [ ] B. 要打开的文件须存在
- [ ] C. 要打开的文件可以不存在
- [ ] D. 打开文件可以读取数据

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C. 要打开的文件可以不存在** 和 **D. 打开文件可以读取数据**

这个题目主要考察了C语言中的文件操作模式。

选项A：文件操作方式为"wb+"，其中的"b"表示二进制模式，但这并不意味着要打开的文件必须是二进制文件，所以这个说法是错误的。

选项B：文件操作方式为"wb+"，其中的"w"表示写模式，如果文件存在，则会清空文件内容；如果文件不存在，则会创建新文件。所以，要打开的文件不必须存在，这个说法是错误的。

选项C：文件操作方式为"wb+"，其中的"w"表示写模式，如果文件不存在，则会创建新文件。所以，要打开的文件可以不存在，这个说法是正确的。

选项D：文件操作方式为"wb+"，其中的"+"表示更新模式，可以读取也可以写入。所以，打开文件可以读取数据，这个说法是正确的。

</details>

## 26. 想对一个文本文件的尾部追加写入","应当在 `fopen` 语句中使用的文件操作方式指示符号为 （）

- [ ] A. w
- [ ] B. r
- [ ] C. wb
- [ ] D. a

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D. a**

这个题目主要考察了C语言中的文件操作模式。

选项A：文件操作方式为"w"，表示写模式，如果文件存在，则会清空文件内容；如果文件不存在，则会创建新文件。所以，这个说法是错误的。

选项B：文件操作方式为"r"，表示读模式，只能读取文件，不能写入文件。所以，这个说法是错误的。

选项C：文件操作方式为"wb"，其中的"w"表示写模式，如果文件存在，则会清空文件内容；如果文件不存在，则会创建新文件。其中的"b"表示二进制模式，但这并不影响对文件的写入。所以，这个说法是错误的。

选项D：文件操作方式为"a"，表示追加模式，如果文件存在，则写入的数据会被添加到文件的末尾；如果文件不存在，则会创建新文件。所以，这个说法是正确的。

</details>

## 27. `#include <filename.h>` 和 `#include "filename.h"` 有什么区别？

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

这个题目主要考察了C语言中预处理指令`#include`的两种形式。

`#include <filename.h>`和`#include "filename.h"`的主要区别在于编译器搜索头文件的方式和位置。

`#include <filename.h>`：编译器会在系统头文件所在的目录中搜索`filename.h`。

`#include "filename.h"`：编译器首先在当前的源文件所在的目录中搜索`filename.h`，如果没有找到，然后再在系统头文件所在的目录中搜索。

</details>

## 28. 头文件中的 `ifndef`/`define`/`endif` 有什么作用？

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

这个题目主要考察了C语言中预处理指令`#ifndef`、`#define`和`#endif`的使用，这些指令通常用于防止头文件的重复包含。

`#ifndef`：如果没有定义指定的宏，则执行后续的代码，直到遇到`#endif`为止。

`#define`：定义一个宏。

`#endif`：结束`#ifndef`的范围。

在头文件中，我们通常会使用这些预处理指令来防止头文件的重复包含。例如：

```c
#ifndef HEADER_FILE
#define HEADER_FILE
#endif
```
如果头文件已经被包含，则`HEADER_FILE`宏已经被定义，`#ifndef HEADER_FILE`的条件不满足，所以不会再次包含头文件的内容。

如果头文件没有被包含，则`HEADER_FILE`宏没有被定义，`#ifndef HEADER_FILE`的条件满足，会包含头文件的内容，并定义`HEADER_FILE`宏，防止头文件的再次包含。

</details>

## 29. 写一个“标准”宏`MIN`, 这个宏满足输入两个参数返回较小的一个（  ）

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

这个题目主要考察了C语言中宏定义的使用。在C语言中，我们可以使用`#define`预处理指令来定义宏。宏可以带有参数，这种宏称为带参数的宏定义或宏函数。

为了实现一个返回两个参数中较小值的宏`MIN`，我们可以使用条件运算符`?:`。条件运算符`?:`的形式为`condition ? expression1 : expression2`，如果`condition`为真，则结果为`expression1`，否则结果为`expression2`。

所以，我们可以定义`MIN`宏如下：

```c
#define MIN(a, b) ((a) < (b) ? (a) : (b))
```

</details>