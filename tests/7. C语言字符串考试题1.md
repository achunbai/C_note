# C语言字符串考试题1

## 1. 【单选题】若定义： `int a = 511 ， *b=&a;` 则 `printf("%d\n", b)`；的输出结果为 ()

- [ ] A. 无确定值
- [ ] B. a 的地址
- [ ] C. 512
- [ ] D. 511

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B**

指针变量b指向a的地址，而输出时输出的为b的值，即a的地址。
</details>

## 2. 【单选题】若有语句 `int *p, a = 10 ； p=&a; `下面均代表地址的一组选项是 ()

- [ ] A. `a, p, *&a`
- [ ] B. `&*a, &a, *p`
- [ ] C. `*&p, *p, &a`
- [ ] D. `&a, &*p, p`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D**

1. 选项A：`a`是一个整型变量，不是地址；`p`是一个指针变量，它的值是一个地址；`*&a`是取变量`a`的地址后再解引用，得到的还是`a`，不是地址。
2. 选项B：`&*a是`错误的，因为`a`不是一个指针，不能被解引用；`&a`是取变量`a`的地址，是一个地址；`*p`是解引用指针`p`，得到的是`p`指向的值，不是地址。
3. 选项C：`*&p`是取指针`p`的地址后再解引用，得到的还是`p`，是一个地址；`*p`是解引用指针`p`，得到的是`p`指向的值，不是地址；`&a`是取变量`a`的地址，是一个地址。
4. 选项D：`&a`是取变量`a`的地址，是一个地址；`&*p`是解引用指针`p`后再取地址，得到的还是`p`指向的地址，是一个地址；`p`是一个指针变量，它的值是一个地址。
</details>

## 3. 【单选题】若有说明： `int *p, a = 1 ， b; `以下正确的程序段是（）

- [ ] A. `p = &b;   scanf("%d" &p);`
- [ ] B. `scanf("%d" &b);   *p=b;`
- [ ] C. `p=&b;     scanf("%d" *p);`
- [ ] D. `p=&b;     *p=a;`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D**

1. 选项A：`p = &b; scanf("%d" &p); `这是错误的。`scanf`函数的参数应该是一个地址，但是`&p`是指针`p`的地址，而不是`p`指向的地址。
2. 选项B：`scanf("%d" &b); *p=b; `这是错误的。`scanf`函数的参数应该是一个地址，这里应该写成`scanf("%d", &b);`。另外，这里没有给指针`p`赋值，所以`*p=b;`可能会导致未定义的行为。
3. 选项C：`p=&b; scanf("%d" *p); `这是错误的。`scanf`函数的参数应该是一个地址，但是`*p`是`p`指向的值，而不是地址。
4. 选项D：`p=&b; *p=a; `这是正确的。这段代码将`b`的地址赋给了指针`p`，然后将`a`的值赋给了`p`指向的地址，也就是`b`。
</details>

## 4. 【单选题】下面判断正确的是（）

- [ ] A. `char *s="girl"; `等价于 `char *s; *s="girl";`
- [ ] B. `char s[10]={"girl"};`等价于`char s[10]; s[10]={"girl"};`
- [ ] C. `char *s="girl";`等价于 `char *s; s="girl";`
- [ ] D. `char s[4]= "boy", t[4]= "boy";`等价于 `char s[4]=t[4]= "boy"`
- [ ] E. `char s[10]={"girl"};`等价于 `char s[10]; s="girl";`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C**

1. A选项，`*s = "girl"`错误，`s`为野指针，无法进行取*访问；
2. B选项，`s = {"girl"}`错误，`s`为数组名，是常量，无法对常量进行修改；
3. C选项，正确，将`"girl"`这个字符串常量的首地址赋值给了`s`这个`char`类型的指针；
4. D选项，`char s[4] = t[4] = "boy"`错误，无法在定义时用连等初始化。
5. E选项，`char s[10]; s="girl";`错误，s为常量，无法对常量进行赋值。
</details>

## 5. 【单选题】以下不能正确进行字符串赋初值的语句是（）

- [ ] A. `char str[5]= "good!";`
- [ ] B. `char *str="good!";`
- [ ] C. `char str[]="good!";`
- [ ] D. `char str[5]={'g', 'o','o', 'd'};`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **A**

A选项中字符串`"good!"`一共需要6个字节来存储，而str只提供了5个字节，会发生溢出（没有地方存`'\0'`），故不能正确进行字符串赋初值，
</details>

## 6. 【单选题】若有以下定义和语句：`int s[4][5], (*ps)[5];ps=s;`则对s数组元素的正确引用形式是（）


- [ ] A. `ps+1`
- [ ] B. `*(ps+3)`
- [ ] C. `ps[0][2]`
- [ ] D. `*(ps+1)+3`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C**

**`ps`为数组指针，指向一个含有五个整数的数组。**

1. 选项A：`ps+1`。`ps`是一个指向含有5个整数的一维数组的指针，所以`ps+1`会将`ps`向前移动一个这样的数组的长度，也就是说，`ps+1`指向`s`的第二行。但是这个表达式并没有引用`s`数组的任何元素，它只是产生了一个新的指针，即`ps+1`只是指向了`s`的第二行，表示`s`第二行首元素的地址，而不是一个元素。
2. 选项B：`*(ps+3)`。这个表达式首先将`ps`向前移动3个这样的数组的长度，也就是说，`ps+3`指向`s`的第四行。然后，`*`操作符解引用这个指针，得到`s`的第四行。但是这个表达式并没有引用s数组的任何元素，它只是产生了一个新的指针，即`ps+3`只是指向了`s`的第四行，表示`s`第四行首元素的地址，而不是一个元素。
3. 选项C：`ps[0][2]`。这个表达式首先使用`[]`操作符从`ps`指向的数组中取出第一个元素，也就是`s`的第一行。然后，它从这个一维数组中取出第三个元素，也就是`s`数组第一行第三列的元素。所以，这个表达式引用的是`s`数组的一个具体元素。
4. 选项D：`*(ps+1)+3`。这个表达式首先将`ps`向前移动一个这样的数组的长度，也就是说，`ps+1`指向`s`的第二行。
   然后，`*`操作符解引用这个指针，得到`s`的第二行。
   最后，`+3`将这个指针向前移动3个整数的长度，也就是说，`*(ps+1)+3`指向`s`的第二行第四个元素的位置。
   但是这个表达式并没有引用`s`数组的任何元素，它只是产生了一个新的指针，即`*(ps+1)+3 --> ps[1]+3`。
   它们都表示`s`数组第二行第四个元素的地址。
   如果想要取得该元素的值，应该使用`ps[1][3]`或者`*(*(ps+1)+3)`，这两种方式都可以。
   `ps[1][3]`是更常见的方式，它直接通过数组下标访问元素。
   `*(*(ps+1)+3)`则是通过指针解引用来访问元素，它首先通过`*(ps+1)`得到`s`数组的第二行，然后通过`+3`得到第四个元素的地址，最后再通过`*`操作符取得该地址处的值。
</details>

## 7. 【单选题】若已定义`char s[10]`;则在下面表达式中不表示`s[1]`地址的是（）

- [ ] A. `s+1`
- [ ] B. `++s`
- [ ] C. `&s[0]+1`
- [ ] D. `&s[1]`

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B**

`++s`等同于`s = s + 1`，而s为常量，存储在常量区，无法被赋值修改，故该语句非法并且不表示`s[1]`的地址。

1. 选项A：`s+1`。在C语言中，数组名是一个指向数组第一个元素的指针，所以`s`是一个指向`s[0]`的指针。`s+1`将这个指针向前移动一个字符的长度，所以它指向`s[1]`。这个表达式表示的是`s[1]`的地址。
2. 选项B：`++s`。这个表达式试图将`s`向前移动一个字符的长度。但是，`s`是一个数组名，它是一个常量，不能被修改。所以这个表达式是非法的，它不表示任何地址。
3. 选项C：`&s[0]+1`。这个表达式首先取得`s[0]`的地址，然后将这个地址向前移动一个字符的长度。所以它指向`s[1]`。这个表达式表示的是`s[1]`的地址。
4. 选项D：`&s[1]`。这个表达式直接取得`s[1]`的地址。所以它表示的是`s[1]`的地址。
</details>

## 8. 【单选题】下列程序的输出结果是（）

```C
#include <stdio.h>
void main() 
{
	int a[] = {1,2,3,4,5,6,7,8,9,0}, *p;
    p = a;
	printf("%d\n", *p + 9);
}
```

- [ ] A. 0
- [ ] B. 1
- [ ] C. 10
- [ ] D. 9

<details>
<summary><font color=red>查看解析</font></summary>

选择 **C**

在这个程序中，首先定义了一个整数数组`a`，然后定义了一个指向整数的指针`p`。然后，`p`被赋值为`a`，这意味着p现在指向数组`a`的第一个元素，即`a[0]`。

然后，程序打印出`*p + 9`的值。`*p`是`p`指向的元素的值，也就是`a[0]`的值，即`1`。所以`*p + 9`的值是`1 + 9`，即`10`。

```C
#include <stdio.h>
void main() 
{
	int a[] = {1,2,3,4,5,6,7,8,9,0}, *p;
    // p指向a的首元素
    p = a;
    // 注意是*p + 9，而不是*(p + 9)
    // *p + 9表示a[0] + 9 = 10
    // *(p + 9)表示a[9] = 0
	printf("%d\n", *p + 9);
}
```
</details>

## 9. 【单选题】以下程序运行后的输出结果是（）

```C
#include <stdio.h>
#include <string.h>
void main() 
{
	char *p="abcde\0fghjik\0";
	printf("%d\n", strlen(p));
}
```

- [ ] A. 12
- [ ] B. 15
- [ ] C. 6
- [ ] D. 5

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D**

这道题目是关于C语言中字符串和`strlen`函数的使用。在C语言中，字符串是由字符组成的，以`\0`（空字符）作为结束标志。`strlen`函数用于计算字符串的长度，但是它不包括结束标志`\0`。

在这个程序中，定义了一个指向字符的指针p，并将其初始化为字符串`"abcde\0fghjik\0"`。然后，程序打印出`strlen(p)`的值。

`strlen(p)`计算的是从`p`指向的位置开始，到第一个`\0`字符之间的字符数量。在这个字符串中，第一个`\0`字符出现在`"abcde"`之后，所以`strlen(p)`的值是`5`。

也需要注意八进制数的问题，如果\0后面接的数字小于8，则其为八进制数，为一个转义字符。
</details>

## 10. 【单选题】对下述代码不正确的叙述是（）

```C
char a[] = "It is mine";
char*  p = "It is mine";
```

- [ ] A. `a+1`表示的是字符`t`的地址
- [ ] B. `p`指向另外的字符串时，字符串的长度不受限制
- [ ] C. `p`变量中存放的地址值可以改变
- [ ] D. `a`中只能存放`10`个字符

<details>
<summary><font color=red>查看解析</font></summary>

选择 **D**

1. 选项A：`a+1`表示的是字符`t`的地址。这个叙述是正确的。在C语言中，数组名是一个指向数组第一个元素的指针，所以`a`是一个指向字符`'I'`的指针。`a+1`将这个指针向前移动一个字符的长度，所以它指向字符`t`。
   需要注意`&a+1`，`&a+1`的含义与`a+1`是不同的。`&a`取的是数组`a`的地址，而不是首元素的地址。在C语言中，`&a`的类型是指向数组的指针，而不是指向单个元素的指针。
   当我们对这个指向数组的指针进行加1操作，`&a+`1，它会跳过整个数组，指向数组后面的内存位置。也就是说，`&a+1`指向的是数组a之后的内存位置，而不是数组的第二个元素。
   所以，`&a+1`并不表示字符t的地址，而是表示数组`a`之后的内存位置的地址。
2. 选项B：`p`指向另外的字符串时，字符串的长度不受限制。这个叙述是正确的。`p`是一个指向字符的指针，它可以指向任何长度的字符串。
3. 选项C：`p`变量中存放的地址值可以改变。这个叙述是正确的。`p`是一个指针，它的值可以被改变，也就是说，它可以被重新指向另一个地址。
4. 选项D：`a`中只能存放`10`个字符。这个叙述是不正确的。`a`是一个字符数组，它的大小是由初始化时的字符串长度决定的。在这个例子中，`a`被初始化为字符串`"It is mine"`，这个字符串包含`11`个字符和一个结束符`\0`，所以`a`的大小是`12`，可以存放`12`个字符，而不是`10`个。
</details>

## 11. 【单选题】设有如下的程序段，执行完下面程序段后，`*(ptr+5)`的值为(     )

```C
char* ptr = NULL;
char str[] = "Hello";
ptr = str;
```

- [ ]  A. 'o'
- [ ]  B. '\0'
- [ ]  C. 'o'的地址
- [ ]  D. 不确定的值

<details>
<summary><font color=red>查看解析</font></summary>

选择 **B**

这道题目是关于C语言中字符串和指针的使用。在这个程序中，首先定义了一个指向字符的指针`ptr`，并将其初始化为`NULL`。然后定义了一个字符数组`str`，并将其初始化为字符串`"Hello"`。最后，`ptr`被赋值为`str`，这意味着`ptr`现在指向`str`的第一个元素，即`str[0]`。

然后，题目问的是`*(ptr+5)`的值是什么。`ptr+5`表示的是`ptr`向前移动5个字符的位置。由于`ptr`指向的是`str[0]`，所以`ptr+5`指向的是`str[5]`。在C语言中，字符串是以`\0`（空字符）作为结束标志的，所以`str[5]`的值是`\0`。

所以，`*(ptr+5)`的值是`\0`，对应的选项是B。
</details>

## 12. 【填空题】以下程序的输出结果是 ( ) 

```C
#include <stdio.h>
int main() 
{
	char *p = "abcdefgh",*r;
	int *q;
	q = (int *) p;
	q++;
	r = (char *) q;
    r++;
	printf("%s\n", r);
    return 0;
}
```

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**输出结果为：`fgh`**

这道题目是关于C语言中指针类型转换和指针运算的。在这个程序中，首先定义了一个指向字符的指针`p`，并将其初始化为字符串`"abcdefgh"`。然后定义了一个指向整数的指针`q`和一个指向字符的指针r。

接下来，`q`被赋值为`p`的值，但是进行了类型转换，将`p`从`char *`转换为`int *`。这意味着`q`现在指向的是`p`指向的内存位置，但是`q`将这个内存位置视为一个整数的开始位置。

然后，`q`进行了加1操作。在C语言中，指针的加1操作会将指针向前移动它所指向的类型的大小。由于`q`是一个`int *`，所以`q++`将`q`向前移动一个整数的大小。在大多数现代计算机系统中，一个整数的大小是4个字节。

接下来，`r`被赋值为`q`的值，但是进行了类型转换，将q从`int *`转换为`char *`。这意味着`r`现在指向的是q指向的内存位置，但是`r`将这个内存位置视为一个字符的开始位置。

然后，r进行了加1操作。由于`r`是一个`char *`，所以`r++`将`r`向前移动一个字符的大小，即1个字节。

最后，程序打印出r指向的字符串。由于`r`指向的是p的第5个字符（`p`的第0个字符是`'a'`，第4个字符是`'e'`，第5个字符是`'f'`），所以打印出的字符串是`"fgh"`。

```C
#include <stdio.h>
int main() 
{
    char *p = "abcdefgh",*r;
    int *q;
    // p强制类型转换为int*，给q赋值
    q = (int *) p;
    // q++ --> q + sizeof(int)
    // 实际上q向后偏移了四个字节
    // 此时q指向p[4]，即p指向的字符串常量中第五个字符'e'
    q++;
    // 将q强制类型转换为char*，给r赋值
    // 此时r指向'e'
    r = (char *) q;
    // r++ --> r + sizeof(char)
    // 实际r向后偏移了1个字符
    // 此时r指向p[5]，即'f'
    r++;
    // 输出字符串时以'\0'结尾，故输出fgh
    printf("%s\n", r);
    return 0;
}
```
</details>

## 13. 【填空题】若有定义：`int a[]={1,2,3,4,5,6,7,8,9,10,11,12}, *p[3], m;` 则下面程序段的输出是 ( ) 

```C
for (m=0; m<3; m++) 
    p[m] = &a[m*4];
printf("%d\n", p[2][2]);
```

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**输出结果为：11**

这道题目是关于C语言中数组和指针的使用的。

首先，定义了一个整数数组`a`和一个指向整数的指针数组`p`，以及一个整数`m`。

然后，通过一个循环，将`p`数组的每个元素指向a数组的不同部分。具体来说，`p[0]`指向`a[0]`，`p[1]`指向`a[4]`，`p[2]`指向`a[8]`。

最后，打印`p[2][2]`的值。由于`p[2]`指向`a[8]`，所以`p[2][2]`实际上是`a[10]`，即数组`a`的第11个元素。由于数组`a`的元素是从1开始的连续整数，所以`a[10]`的值是11。

所以，这个程序的输出结果是11。

```C
int a[]={1,2,3,4,5,6,7,8,9,10,11,12}, *p[3], m;
for (m=0; m<3; m++) 
    // 第一次循环：p[0] = &a[0]
    // 第二次循环：p[1] = &a[4]
    // 第三次循环：p[2] = &a[8]
    // 循环结束
    p[m] = &a[m*4];
// p[2][2] --> *(&a[8]+2) --> *(&a[10]) --> a[10] --> 11
printf("%d\n", p[2][2]);
```
</details>

## 14. 【填空题】int (*s[10])(int)表示的是什么 ( )

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**函数指针数组**

`int (*s[10])(int)`表示的是一个函数指针数组。这个数组有10个元素，每个元素都是一个指向函数的指针，这个函数的参数是一个整数，返回值也是一个整数。

补充：
1. 函数指针：这是一个指针，它指向一个函数。例如，`int (*p)(int)`是一个函数指针，它指向一个接受一个整数参数并返回整数的函数。

2. 函数指针数组：这是一个数组，它的每个元素都是函数指针。例如，`int (*s[10])(int)`是一个函数指针数组，它有10个元素，每个元素都是一个指向接受一个整数参数并返回整数的函数的指针。

3. 指针函数：这是一个函数，它返回一个指针。例如，`int *func(int)`是一个指针函数，它接受一个整数参数并返回一个指向整数的指针。

4. 指针数组：这是一个数组，它的每个元素都是指针。例如，`int *p[10]`是一个指针数组，它有10个元素，每个元素都是一个指向整数的指针。
</details>

## 15. 【填空题】以下程序输出结果 ( ) 

```C
#include<stdio.h>
int main() 
{
	int x, b;
	x = 1;
	b = x = x++;
	printf("%d %d", b, x);
	return 0;
}
```

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**输出结果为：1 2**

这道题目涉及到C语言中的赋值运算符和后置自增运算符的优先级和执行顺序。

在C语言中，后置自增运算符（`x++`）的优先级高于赋值运算符（`=`），但是它的效果（增加x的值）会在整个表达式计算完毕后才会发生。

所以，`b = x = x++;`这行代码的执行过程如下：

`x++`：`x`的值增加1，但是这个效果会在整个表达式计算完毕后才会发生。所以，这个表达式的结果仍然是`x`的原值，即1。

`x = x++`：将`x++`的结果赋值给`x`。由于`x++`的结果是1，所以`x`的值变为1。

`b = x = x++`：将`x`的值赋值给`b`。由于`x`的值是1，所以`b`的值也变为1。

`x++`的效果发生，`x`的值增加1，变为2。

所以，`printf("%d %d", b, x);`的输出结果是1 2。

```C
#include<stdio.h>
int main() 
{
    int x, b;
    x = 1;
    // 两个赋值符号从左往右顺序执行
    // ++运算符优先级最高，比赋值符号优先级高
    // 但这是后置++，所以先返回值后自增
    // 因此，这里给到x的值仍然是1
    b = x = x++;
    // 然后，x++的效果发生，x的值增加1，变为2
    // 所以输出值为1 2
    printf("%d %d", b, x);
    return 0;
}
```
</details>

## 16. 【填空题】输出以下程序结果为 ( ) 

```C
void PutString(char str4[10])
{
    printf("%d ", sizeof(str4));
}
void test() 
{
    char str1[] = "abcdef";
    char *str2 = "abcdef";
    char str3[10] = "abcdef";
    char *str5 = str3;
    printf("%d ", sizeof(str1));
    printf("%d ", sizeof(str2));
    printf("%d ", sizeof(str3));
    printf("%d ", sizeof(str5));
    PutString(str3);
}
```

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

**结果为：7 4 10 4 4**

```C
// sizeof运算符返回的是size_t类型的值，这是一个无符号整数类型。在printf函数中，应该使用%zu格式说明符来打印size_t类型的值，而不是%d。
#include<stdio.h>
void PutString(char str4[10])
{
    // str4在函数内部作为指针处理，所以它的大小是指针的大小
    printf("%zu ", sizeof(str4));
}
void test() 
{
    char str1[] = "abcdef";
    char *str2 = "abcdef";
    char str3[10] = "abcdef";
    char *str5 = str3;
    // str1存储"abcdef"这个字符串，其中有六个字母，还有一个终止符'\0'，故其大小为7*sizeof(char)=7
    printf("%zu ", sizeof(str1));
    // str2为一个指针，其大小仅与编译环境有关，在x86环境下，地址占四字节，在x64环境下，地址占八字节，题目未提及，默认为x86环境，故其大小为4
    printf("%zu ", sizeof(str2));
    // str3为字符数组，其长度定义时规定为10，只不过进行了部分初始化，其余的为'\0'，故其大小仍为10
    printf("%zu ", sizeof(str3));
    // str5为字符类型指针，指向str3的首地址，与str2相同，大小为4
    printf("%zu ", sizeof(str5));
    // 函数形参为str4[10]，但数组作为函数形参时，退化为指针，与str2相同，大小为4
    PutString(str3);
}
```
</details>

## 17. 【简答题】判断一个字符串是否是回文字符串

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

如下

```C
#include <stdio.h>
#include <string.h>

int main()
{
    char str[100];
    // 使用gets函数获取字符串
    gets(str);
    int length = strlen(str);
    // 遍历字符串的前半部分
    for(int i = 0; i < length / 2; i++)
    {
        // 如果前半部分的字符和后半部分的对应字符不相等，那么这个字符串就不是回文字符串
        if(str[i] != str[length - i - 1])
        {
            printf("No!");
            return 0;
        }
    }
    // 如果所有的前半部分的字符和后半部分的对应字符都相等，那么这个字符串就是回文字符串
    printf("Yes!");
    return 0;
}
```
</details>

## 18. 【简答题】输出字符串中出现次数最多的字符（存在相同次数时，输出对应ASCII值较小的字符）

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

如下

```C
#include <stdio.h>
#include <string.h>

int main()
{
    char str[100];
    int cnt[128] = { 0 };
    // 使用gets函数获取字符串
    gets(str);
    int maxCount = 0;
    char maxChar = 0;
    for(int i = 0; i < strlen(str); i++)
    {
        // 统计每个字符出现的次数
        cnt[str[i]]++;
        // 如果当前字符出现的次数大于maxCount，或者出现的次数相同但ASCII值较小，则更新maxCount和maxChar
        if(cnt[str[i]] > maxCount || (cnt[str[i]] == maxCount && str[i] < maxChar))
        {
            maxCount = cnt[str[i]];
            maxChar = str[i];
        }
    }
    // 输出出现次数最多的字符
    printf("%c", maxChar);
    return 0;
}
```
</details>

## 19. 【简答题】判断一个正整数是不是2的n次幂，是返回1，否返回0

<input type='text' placeholder='在这里输入你的答案'>

<details>
<summary><font color=red>查看解析</font></summary>

如下

```C
#include <stdio.h>

int func(int num)
{
    // 如果num是2的n次幂，那么num的二进制表示中只有一个1，其余都是0
    // num - 1的二进制表示中，所有比这个1位小的位都会变成1，这个1位会变成0
    // 因此，num和num - 1的按位与运算的结果一定是0
    // 如果num不是2的n次幂，那么num的二进制表示中至少有两个1，num和num - 1的按位与运算的结果一定不是0
    if(num & (num - 1))
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

int main()
{
    int num;
    // 从标准输入读取一个正整数
    scanf("%d", &num);
    // 打印func(num)的结果
    printf("%d", func(num));
    return 0;
}
```
</details>
