/*
1084：幂的末尾

时间限制: 1000 ms         内存限制: 65536 KB
提交数: 70377     通过数: 40915
【题目描述】
幂ab
的末3
位数是多少？

【输入】
两个正整数a，b
。1≤a≤100，1≤b≤10000
。

【输出】
从高位到低位输出幂的末三位数字，中间无分隔符。若幂本身不足三位，在前面补零。

【输入样例】
7 2011
【输出样例】
743
*/

// 原码、反码、补码
// 原码：符号位+数值位
//		方便还原数值，但是不利于计算机运算，相反数相加时，符号位会发生变化，结果不为0
// 反码：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各位取反
//		相反数相加时，符号位不会发生变化，结果为0，但是0有两个表示，+0和-0
// 补码：正数的补码是其本身，负数的补码是在其反码的基础上，符号位不变，其余各位加1
// 		相反数相加时，符号位不会发生变化，结果为0，且0只有一个表示，即+0，同时引入了最低下限


// 需要注意数据类型范围
// int类型：4字节，32位，-2^31~2^31-1
// 也就是说
// int最大能存储2147483647，即10位数，21开头
// int最小能存储-2147483648，即10位数，-21开头
// long long类型：8字节，64位，-2^63~2^63-1
// 也就是说
// long long最大能存储9223372036854775807，即19位数，92开头
// long long最小能存储-9223372036854775808，即19位数，-92开头
// 在某些评测机中，有__int128类型，16字节，128位，-2^127~2^127-1
// 也就是说
// __int128最大能存储170141183460469231731687303715884105727，即39位数，170开头
// __int128最小能存储-170141183460469231731687303715884105728，即39位数，-170开头
// 但如果这个数据范围还是不够，那么就需要用高精度算法了
// 高精度算法：用数组来存储每一位数，然后进行运算
// 但是高精度算法的效率很低，所以一般不会用到


// 本题的数据范围是：1≤a≤100，1≤b≤10000
// 哪怕是用long long类型，也不够存储
// 所以要用数学思维来解决
// 本题需要用到模运算的性质：
// 		1. (a+b)%c = (a%c + b%c)%c
// 		2. (a-b)%c = (a%c - b%c)%c
// 		3. (a*b)%c = (a%c * b%c)%c
// 		4. (a^b)%c = ((a%c * a%c)%c * a%c)%c*...*a%c)%c
// 注意除法不满足这个性质
#include <stdio.h>

int main()
{
	int a, b, result = 1;
	scanf("%d %d", &a, &b);
	for (int i = 0; i < b; i++)
	{
		result *= a;
		result %= 1000;
	}
    // 注意是末尾三位，不够需要补0
	printf("%03d", result); // %03d表示输出3位，不足3位前面补0
	return 0;
}

/*
// 课上示例C++代码

#include<iostream>
using namespace std;

int main() {
	//正数的原码=反码=补码  
	//负数的反码是在原码的基础上符号位不变，其余各位取反
	//负数的补码是在反码的基础上+1
	
	//原码：方便还原十进制，但是相反数相加不等0
	//反码：相反数相加等于0，但是存在+0和-0两个0
	//补码：相反数相加等于0，只有+0，同时引入了最低下限
	//int-4字节-32bit        -2^31,+2^31-1    21亿+  10^9的数量级
	//long long-8字节-64bit  -2^63,+2^63-1           10^18的数量级
	//__int128-128bit
	//高精度算法
	
	//模运算的性质
	//（1）(a+b)%m=(a%m+b%m)%m
	//（2）(a-b)%m=(a%m-b%m)%m
	//（3）(a*b)%m=(a%m*b%m)%m
	//（4 )(a^b)%m=((a%m*a%m)%m*a%m)%m*a%m...
	
	int a, b,ans=1;
	cin >> a >> b;
	for (int i = 1; i <= b; i++) {
		ans *= a % 1000;
		ans %= 1000;
	}
	//%03d   整数部分占3位，不足3位时，默认补0
	printf("%03d", ans);
	return 0;
}

*/